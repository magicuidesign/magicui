import { exec } from "child_process";
import { promises as fs } from "fs";
import path from "path";
import { rimraf } from "rimraf";
import { registryItemSchema, type Registry } from "shadcn/registry";
import { z } from "zod";

import { examples } from "../registry/registry-examples";
import { lib } from "../registry/registry-lib";
import { ui } from "../registry/registry-ui";
import { siteConfig } from "../config/site";

const DEPRECATED_ITEMS = ["toast"];

const registry = {
  name: "magic-ui",
  homepage: "https://magicui.design",
  items: z.array(registryItemSchema).parse(
    [
      {
        name: "index",
        type: "registry:style",
        dependencies: [
          "tw-animate-css",
          "class-variance-authority",
          "lucide-react",
        ],
        registryDependencies: ["utils"],
        cssVars: {},
        files: [],
      },
      ...ui,
      ...examples,
      ...lib,
    ].filter((item) => {
      return !DEPRECATED_ITEMS.includes(item.name);
    })
  ),
} satisfies Registry;

async function buildRegistryIndex() {
  let index = `/* eslint-disable @typescript-eslint/ban-ts-comment */
/* eslint-disable @typescript-eslint/no-explicit-any */
// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {`;
  for (const item of registry.items) {
    const resolveFiles = item.files?.map((file) => `${file.path}`);
    if (!resolveFiles) {
      continue;
    }

    const componentPath = item.files?.[0]?.path
      ? `@/${item.files[0].path}`
      : "";

    index += `
  "${item.name}": {
    name: "${item.name}",
    description: "${item.description ?? ""}",
    type: "${item.type}",
    registryDependencies: ${JSON.stringify(item.registryDependencies)},
    files: [${item.files?.map((file) => {
      const filePath = `${typeof file === "string" ? file : file.path}`;
      const resolvedFilePath = path.resolve(filePath);
      return typeof file === "string"
        ? `"${resolvedFilePath}"`
        : `{
      path: "${filePath}",
      type: "${file.type}",
      target: "${file.target ?? ""}"
    }`;
    })}],
    component: ${
      componentPath
        ? `React.lazy(async () => {
      const mod = await import("${componentPath}")
      const exportName = Object.keys(mod).find(key => typeof mod[key] === 'function' || typeof mod[key] === 'object') || item.name
      return { default: mod.default || mod[exportName] }
    })`
        : "null"
    },
    meta: ${JSON.stringify(item.meta)},
  },`;
  }

  index += `
  }`;

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/index.tsx"));
  await fs.writeFile(path.join(process.cwd(), "__registry__/index.tsx"), index);
}

async function buildRegistryJsonFile() {
  // 1. Fix the path for registry items.
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `${file.path}`,
        };
      });

      return {
        ...item,
        files,
      };
    }),
  };

  // 2. Write the content of the registry to `registry.json` and public folder
  rimraf.sync(path.join(process.cwd(), `registry.json`));
  rimraf.sync(path.join(process.cwd(), `public/registry.json`));

  const registryJson = JSON.stringify(fixedRegistry, null, 2);

  await fs.writeFile(path.join(process.cwd(), `registry.json`), registryJson);
  await fs.writeFile(
    path.join(process.cwd(), `public/registry.json`),
    registryJson
  );
}

type LlmTxtEntry = {
  title: string;
  description: string;
  source: string;
  "associate-demo": string[];
};

function humanizeName(value: string): string {
  return value
    .split(/[-_]+/)
    .filter(Boolean)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join(" ");
}

async function buildLlmTxtJson() {
  const baseUrl = siteConfig.url.replace(/\/$/, "");
  // Helper to pull meta from local registry JSON if needed
  async function getLocalMeta(
    name: string
  ): Promise<{ title?: string; description?: string }> {
    const p = path.join(process.cwd(), "public", "r", `${name}.json`);
    try {
      const raw = await fs.readFile(p, "utf8");
      const json = JSON.parse(raw) as { title?: string; description?: string };
      return { title: json.title, description: json.description };
    } catch {
      return {};
    }
  }

  // Build a map of component name -> associated demo names (minimal reduce)
  const uiNames = new Set(ui.map((u) => u.name));
  const association: Record<string, Set<string>> = examples.reduce(
    (acc, ex) => {
      const deps = Array.isArray(ex.registryDependencies)
        ? (ex.registryDependencies as string[])
        : [];
      deps.forEach((raw) => {
        const name = raw.split("/").filter(Boolean).pop();
        if (!uiNames.has(name ?? "")) return;
        (acc[name ?? ""] ??= new Set()).add(ex.name);
      });
      return acc;
    },
    {} as Record<string, Set<string>>
  );

  // Starting point: registry_examples (examples variable)
  // Ending point: registry_associations (built below using association)

  const output: Record<string, LlmTxtEntry> = {};

  for (const item of ui) {
    if (item.type !== "registry:ui") continue;
    const localMeta = await getLocalMeta(item.name);
    const title =
      (item as any).title ?? localMeta.title ?? humanizeName(item.name);
    const description =
      (item as any).description ??
      localMeta.description ??
      `The ${title} component.`;
    const source = `${baseUrl}/r/${item.name}.json`;
    const demos = Array.from(association[item.name] ?? []).map(
      (demo) => `${baseUrl}/r/${demo}.json`
    );

    output[item.name] = {
      title,
      description,
      source,
      "associate-demo": demos,
    } satisfies LlmTxtEntry;
  }

  const outPath = path.join(process.cwd(), "public/llm-txt.json");
  await fs.writeFile(outPath, JSON.stringify(output, null, 2));
}

type LocalRegistryFile = {
  path: string;
  content?: string;
  type: string;
  target?: string;
};

type LocalRegistryItem = {
  name: string;
  type: string;
  title?: string;
  description?: string;
  files: LocalRegistryFile[];
};

function urlToLocalRPath(urlStr: string): string | null {
  try {
    const u = new URL(urlStr);
    // expect /r/<name>.json
    const match = u.pathname.match(/\/r\/([^/]+)\.json$/);
    if (!match) return null;
    const name = match[1];
    return path.join(process.cwd(), "public", "r", `${name}.json`);
  } catch {
    return null;
  }
}

async function loadLocalRegistryByUrl(
  urlStr: string
): Promise<LocalRegistryItem | null> {
  const p = urlToLocalRPath(urlStr);
  if (!p) return null;
  try {
    const raw = await fs.readFile(p, "utf8");
    return JSON.parse(raw) as LocalRegistryItem;
  } catch {
    return null;
  }
}

async function readRegistryFilesContents(
  item: LocalRegistryItem
): Promise<string> {
  const pieces: string[] = [];
  for (const f of item.files ?? []) {
    const header = `--- file: ${f.path} ---\n`;
    if (f.content && f.content.length > 0) {
      pieces.push(header + f.content + (f.content.endsWith("\n") ? "" : "\n"));
      continue;
    }
    // Fallback: read from local repo path if available
    try {
      const localPath = path.join(process.cwd(), f.path);
      const text = await fs.readFile(localPath, "utf8");
      pieces.push(header + text + (text.endsWith("\n") ? "" : "\n"));
    } catch {
      pieces.push(header + "// [content not available]\n");
    }
  }
  return pieces.join("\n");
}

async function buildLlmTxtFile() {
  const jsonPath = path.join(process.cwd(), "public", "llm-txt.json");
  const exists = await fs
    .access(jsonPath)
    .then(() => true)
    .catch(() => false);
  if (!exists) return;

  const raw = await fs.readFile(jsonPath, "utf8");
  const map = JSON.parse(raw) as Record<
    string,
    {
      title: string;
      description: string;
      source: string;
      "associate-demo": string[];
    }
  >;

  const names = Object.keys(map).sort((a, b) => a.localeCompare(b));
  const sections: string[] = [];

  for (const name of names) {
    const entry = map[name];
    const srcItem = await loadLocalRegistryByUrl(entry.source);
    if (srcItem) {
      sections.push(
        `===== MAIN COMPONENT: ${srcItem.name} (${srcItem.type}) =====\n` +
          `Title: ${entry.title}\n` +
          `Description: ${entry.description}\n\n` +
          (await readRegistryFilesContents(srcItem))
      );
    } else {
      sections.push(
        `===== MAIN COMPONENT: ${name} =====\n` +
          `Title: ${entry.title}\n` +
          `Description: ${entry.description}\n\n` +
          `// [source ${entry.source} not available]\n`
      );
    }

    for (const demoUrl of entry["associate-demo"]) {
      const demoItem = await loadLocalRegistryByUrl(demoUrl);
      if (!demoItem) {
        sections.push(
          `\n===== EXAMPLE: ${demoUrl} =====\n` + `// [demo not available]\n`
        );
        continue;
      }
      const demoHeader =
        `\n\n===== EXAMPLE: ${demoItem.name} (${demoItem.type}) =====\n` +
        (demoItem.title ? `Title: ${demoItem.title}\n` : "") +
        (demoItem.description
          ? `Description: ${demoItem.description}\n\n`
          : "\n");
      sections.push(demoHeader + (await readRegistryFilesContents(demoItem)));
    }
  }

  const outTxt = sections.join("\n\n\n");
  // Write to project root
  const target = path.join(process.cwd(), "llm.txt");
  await fs.writeFile(target, outTxt, "utf8");
  // Also write to public for sharing
  const publicDir = path.join(process.cwd(), "public");
  try {
    await fs.mkdir(publicDir, { recursive: true });
  } catch {}
  const publicTarget = path.join(publicDir, "llm.txt");
  await fs.writeFile(publicTarget, outTxt, "utf8");
}

async function buildRegistry() {
  return new Promise((resolve, reject) => {
    const process = exec(`pnpm shadcn:build`);

    process.on("exit", (code) => {
      if (code === 0) {
        resolve(undefined);
      } else {
        reject(new Error(`Process exited with code ${code}`));
      }
    });
  });
}

try {
  console.log("üóÇÔ∏è Building registry/__index__.tsx...");
  await buildRegistryIndex();
  console.log("‚úÖ Registry index built successfully");

  console.log("üíÖ Building registry.json...");
  await buildRegistryJsonFile();
  console.log("‚úÖ Registry JSON file built successfully");

  console.log("üßæ Building public/llm-txt.json...");
  await buildLlmTxtJson();
  console.log("‚úÖ llm-txt.json built successfully");

  console.log("üß† Building llm.txt...");
  await buildLlmTxtFile();
  console.log("‚úÖ llm.txt built successfully");

  console.log("üèóÔ∏è Building registry...");
  await buildRegistry();
  console.log("‚úÖ Registry build completed");
} catch (error) {
  console.error("‚ùå Build failed with error:");
  console.error(error);
  if (error instanceof Error) {
    console.error("Error stack:", error.stack);
  }
  process.exit(1);
}
