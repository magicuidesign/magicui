{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "blob-background",
  "type": "registry:ui",
  "title": "Blob Background",
  "description": "A good-looking animated blob background.",
  "files": [
    {
      "path": "registry/magicui/blob-background.tsx",
      "content": "\"use client\"\r\n\r\nimport * as React from \"react\"\r\nimport { cn } from \"@/lib/utils\"\r\n\r\nexport interface BlobBackgroundProps extends React.HTMLAttributes<HTMLDivElement> {\r\n    /**\r\n     * Number of blobs to render\r\n     * @default 8\r\n     */\r\n    blobCount?: number\r\n    /**\r\n     * Base size of the blobs (will vary slightly)\r\n     * @default 250\r\n     */\r\n    blobSize?: number\r\n    /**\r\n     * How far blobs can move from center\r\n     * @default 150\r\n     */\r\n    range?: number\r\n    /**\r\n     * How fast the colors change (ms)\r\n     * @default 5000\r\n     */\r\n    speed?: number\r\n    /**\r\n     * Blur amount for the blobs\r\n     * @default 60\r\n     */\r\n    blur?: number\r\n}\r\n\r\ninterface Blob {\r\n    x: number\r\n    y: number\r\n    baseX: number\r\n    baseY: number\r\n    radius: number\r\n    angle: number\r\n    speed: number\r\n    range: number\r\n    color: {\r\n        current: RGB\r\n        target: RGB\r\n    }\r\n}\r\n\r\ninterface RGB {\r\n    r: number\r\n    g: number\r\n    b: number\r\n}\r\n\r\nconst color = (): RGB => {\r\n    const hue = Math.random() * 360\r\n    const saturation = 80 + Math.random() * 20\r\n    const lightness = 50 + Math.random() * 10\r\n    const h = hue / 360\r\n    const s = saturation / 100\r\n    const l = lightness / 100\r\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s\r\n    const p = 2 * l - q\r\n\r\n    const convertHue = (t: number) => {\r\n        if (t < 0) t += 1\r\n        if (t > 1) t -= 1\r\n        if (t < 1 / 6) return p + (q - p) * 6 * t\r\n        if (t < 1 / 2) return q\r\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6\r\n        return p\r\n    }\r\n\r\n    return {\r\n        r: Math.round(convertHue(h + 1 / 3) * 255),\r\n        g: Math.round(convertHue(h) * 255),\r\n        b: Math.round(convertHue(h - 1 / 3) * 255),\r\n    }\r\n}\r\n\r\nexport function BlobBackground({\r\n    className,\r\n    blobCount = 8,\r\n    blobSize = 250,\r\n    range = 150,\r\n    speed = 5000,\r\n    blur = 60,\r\n    ...props\r\n}: BlobBackgroundProps) {\r\n    const canvasRef = React.useRef<HTMLCanvasElement>(null)\r\n    const offscreenRef = React.useRef<OffscreenCanvas | null>(null)\r\n    const animationRef = React.useRef<number>()\r\n    const blobsRef = React.useRef<Blob[]>([])\r\n\r\n    React.useEffect(() => {\r\n        const canvas = canvasRef.current\r\n        if (!canvas) return\r\n        const ctx = canvas.getContext(\"2d\")\r\n        if (!ctx) return\r\n\r\n        offscreenRef.current = new OffscreenCanvas(1, 1)\r\n        const offscreenCtx = offscreenRef.current.getContext(\"2d\")\r\n        if (!offscreenCtx) return\r\n\r\n        const handleResize = () => {\r\n            const width = window.innerWidth\r\n            const height = window.innerHeight\r\n            canvas.width = width\r\n            canvas.height = height\r\n\r\n            if (offscreenRef.current) {\r\n                offscreenRef.current.width = width\r\n                offscreenRef.current.height = height\r\n            }\r\n\r\n            initializeBlobs(width, height)\r\n        }\r\n\r\n        const initializeBlobs = (width: number, height: number) => {\r\n            const centerX = width / 2\r\n            const centerY = height / 2\r\n\r\n            blobsRef.current = Array.from({ length: blobCount }, (_, i) => {\r\n                const initialColor = color()\r\n                const targetColor = color()\r\n                const angle = (i / blobCount) * Math.PI * 2\r\n\r\n                return {\r\n                    baseX: centerX,\r\n                    baseY: centerY,\r\n                    x: centerX,\r\n                    y: centerY,\r\n                    radius: Math.random() * (blobSize * 0.4) + blobSize,\r\n                    angle,\r\n                    speed: 0.002 + Math.random() * 0.001,\r\n                    range: range + Math.random() * (range * 0.3),\r\n                    color: {\r\n                        current: initialColor,\r\n                        target: targetColor,\r\n                    },\r\n                }\r\n            })\r\n        }\r\n\r\n        handleResize()\r\n        window.addEventListener(\"resize\", handleResize)\r\n\r\n        const colorInterval = setInterval(() => {\r\n            blobsRef.current.forEach((blob) => {\r\n                blob.color.target = color()\r\n            })\r\n        }, speed)\r\n\r\n        let time = 0\r\n        const animate = () => {\r\n            if (!canvas || !offscreenRef.current) return\r\n\r\n            const offscreenCtx = offscreenRef.current.getContext(\"2d\")\r\n            if (!offscreenCtx || !ctx) return\r\n\r\n            time += 0.01\r\n\r\n            ctx.fillStyle = \"black\"\r\n            ctx.fillRect(0, 0, canvas.width, canvas.height)\r\n\r\n            offscreenCtx.fillStyle = \"black\"\r\n            offscreenCtx.fillRect(0, 0, offscreenRef.current.width, offscreenRef.current.height)\r\n\r\n            blobsRef.current.forEach((blob) => {\r\n                blob.angle += blob.speed\r\n                const wobble = Math.sin(time + blob.angle) * 30\r\n                blob.x = blob.baseX + Math.cos(blob.angle) * (blob.range + wobble)\r\n                blob.y = blob.baseY + Math.sin(blob.angle * 1.5) * (blob.range + wobble)\r\n\r\n                blob.color.current.r += (blob.color.target.r - blob.color.current.r) * 0.01\r\n                blob.color.current.g += (blob.color.target.g - blob.color.current.g) * 0.01\r\n                blob.color.current.b += (blob.color.target.b - blob.color.current.b) * 0.01\r\n\r\n                const gradient = offscreenCtx.createRadialGradient(blob.x, blob.y, 0, blob.x, blob.y, blob.radius)\r\n\r\n                const { r, g, b } = blob.color.current\r\n                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`)\r\n                gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.3)`)\r\n                gradient.addColorStop(1, \"rgba(0, 0, 0, 0)\")\r\n\r\n                offscreenCtx.fillStyle = gradient\r\n                offscreenCtx.beginPath()\r\n                offscreenCtx.arc(blob.x, blob.y, blob.radius, 0, Math.PI * 2)\r\n                offscreenCtx.fill()\r\n            })\r\n            ctx.filter = `blur(${blur}px)`\r\n            ctx.drawImage(offscreenRef.current, 0, 0)\r\n            ctx.filter = \"none\"\r\n\r\n            animationRef.current = requestAnimationFrame(animate)\r\n        }\r\n\r\n        animate()\r\n\r\n        return () => {\r\n            window.removeEventListener(\"resize\", handleResize)\r\n            clearInterval(colorInterval)\r\n            if (animationRef.current) {\r\n                cancelAnimationFrame(animationRef.current)\r\n            }\r\n        }\r\n    }, [blobCount, blobSize, range, speed, blur])\r\n\r\n    return (\r\n        <div className={cn(\"relative min-h-screen w-full overflow-hidden bg-black\", className)} {...props}>\r\n            <canvas ref={canvasRef} className=\"absolute top-0 left-0 w-full h-full\" aria-hidden=\"true\" />\r\n        </div>\r\n    )\r\n}",
      "type": "registry:ui",
      "target": "components/magicui/blob-background.tsx"
    }
  ]
}