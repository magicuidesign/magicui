{
  "name": "scratch-to-reveal",
  "type": "registry:ui",
  "dependencies": [
    "motion"
  ],
  "files": [
    {
      "path": "magicui/scratch-to-reveal.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport React, { useRef, useEffect, useState } from \"react\";\nimport { motion, useAnimation } from \"motion/react\";\n\ninterface ScratchToRevealProps {\n  children: React.ReactNode;\n  width: number;\n  height: number;\n  minScratchPercentage?: number;\n  className?: string;\n  onComplete?: () => void;\n  gradientColors?: [string, string, string];\n}\n\nconst ScratchToReveal: React.FC<ScratchToRevealProps> = ({\n  width,\n  height,\n  minScratchPercentage = 50,\n  onComplete,\n  children,\n  className,\n  gradientColors = [\"#A97CF8\", \"#F38CB8\", \"#FDCC92\"],\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [isScratching, setIsScratching] = useState(false);\n  const [isComplete, setIsComplete] = useState(false);\n\n  const controls = useAnimation();\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext(\"2d\");\n    if (canvas && ctx) {\n      ctx.fillStyle = \"#ccc\";\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      const gradient = ctx.createLinearGradient(\n        0,\n        0,\n        canvas.width,\n        canvas.height,\n      );\n      gradient.addColorStop(0, gradientColors[0]);\n      gradient.addColorStop(0.5, gradientColors[1]);\n      gradient.addColorStop(1, gradientColors[2]);\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n  }, [gradientColors]);\n\n  useEffect(() => {\n    const handleDocumentMouseMove = (event: MouseEvent) => {\n      if (!isScratching) return;\n      scratch(event.clientX, event.clientY);\n    };\n\n    const handleDocumentTouchMove = (event: TouchEvent) => {\n      if (!isScratching) return;\n      const touch = event.touches[0];\n      scratch(touch.clientX, touch.clientY);\n    };\n\n    const handleDocumentMouseUp = () => {\n      setIsScratching(false);\n      checkCompletion();\n    };\n\n    const handleDocumentTouchEnd = () => {\n      setIsScratching(false);\n      checkCompletion();\n    };\n\n    document.addEventListener(\"mousedown\", handleDocumentMouseMove);\n    document.addEventListener(\"mousemove\", handleDocumentMouseMove);\n    document.addEventListener(\"touchstart\", handleDocumentTouchMove);\n    document.addEventListener(\"touchmove\", handleDocumentTouchMove);\n    document.addEventListener(\"mouseup\", handleDocumentMouseUp);\n    document.addEventListener(\"touchend\", handleDocumentTouchEnd);\n    document.addEventListener(\"touchcancel\", handleDocumentTouchEnd);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", handleDocumentMouseMove);\n      document.removeEventListener(\"mousemove\", handleDocumentMouseMove);\n      document.removeEventListener(\"touchstart\", handleDocumentTouchMove);\n      document.removeEventListener(\"touchmove\", handleDocumentTouchMove);\n      document.removeEventListener(\"mouseup\", handleDocumentMouseUp);\n      document.removeEventListener(\"touchend\", handleDocumentTouchEnd);\n      document.removeEventListener(\"touchcancel\", handleDocumentTouchEnd);\n    };\n  }, [isScratching]);\n\n  const handleMouseDown = () => setIsScratching(true);\n\n  const handleTouchStart = () => setIsScratching(true);\n\n  const scratch = (clientX: number, clientY: number) => {\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext(\"2d\");\n    if (canvas && ctx) {\n      const rect = canvas.getBoundingClientRect();\n      const x = clientX - rect.left + 16;\n      const y = clientY - rect.top + 16;\n      ctx.globalCompositeOperation = \"destination-out\";\n      ctx.beginPath();\n      ctx.arc(x, y, 30, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  };\n\n  const startAnimation = async () => {\n    await controls.start({\n      scale: [1, 1.5, 1],\n      rotate: [0, 10, -10, 10, -10, 0],\n      transition: { duration: 0.5 },\n    });\n\n    // Call onComplete after animation finishes\n    if (onComplete) {\n      onComplete();\n    }\n  };\n\n  const checkCompletion = () => {\n    if (isComplete) return;\n\n    const canvas = canvasRef.current;\n    const ctx = canvas?.getContext(\"2d\");\n    if (canvas && ctx) {\n      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      const pixels = imageData.data;\n      const totalPixels = pixels.length / 4;\n      let clearPixels = 0;\n\n      for (let i = 3; i < pixels.length; i += 4) {\n        if (pixels[i] === 0) clearPixels++;\n      }\n\n      const percentage = (clearPixels / totalPixels) * 100;\n\n      if (percentage >= minScratchPercentage) {\n        setIsComplete(true);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        startAnimation();\n      }\n    }\n  };\n\n  return (\n    <motion.div\n      className={cn(\"relative select-none\", className)}\n      style={{\n        width,\n        height,\n        cursor:\n          \"url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMiIgaGVpZ2h0PSIzMiIgdmlld0JveD0iMCAwIDMyIDMyIj4KICA8Y2lyY2xlIGN4PSIxNiIgY3k9IjE2IiByPSIxNSIgc3R5bGU9ImZpbGw6I2ZmZjtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6MXB4OyIgLz4KPC9zdmc+'), auto\",\n      }}\n      animate={controls}\n    >\n      <canvas\n        ref={canvasRef}\n        width={width}\n        height={height}\n        className=\"absolute left-0 top-0\"\n        onMouseDown={handleMouseDown}\n        onTouchStart={handleTouchStart}\n      ></canvas>\n      {children}\n    </motion.div>\n  );\n};\n\nexport default ScratchToReveal;\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}