{
  "name": "flickering-grid",
  "type": "registry:ui",
  "dependencies": [
    "framer-motion"
  ],
  "files": [
    {
      "path": "magicui/flickering-grid.tsx",
      "content": "\"use client\";\n\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\ninterface FlickeringGridProps {\n  squareSize?: number;\n  gridGap?: number;\n  flickerChance?: number;\n  color?: string;\n  width?: number;\n  height?: number;\n  className?: string;\n  maxOpacity?: number;\n}\n\nconst FlickeringGrid: React.FC<FlickeringGridProps> = ({\n  squareSize = 4,\n  gridGap = 6,\n  flickerChance = 0.3,\n  color = \"rgb(0, 0, 0)\",\n  width,\n  height,\n  className,\n  maxOpacity = 0.3,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [isInView, setIsInView] = useState(false);\n\n  const memoizedColor = useMemo(() => {\n    const toRGBA = (color: string) => {\n      if (typeof window === \"undefined\") {\n        return `rgba(0, 0, 0,`;\n      }\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = canvas.height = 1;\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) return \"rgba(255, 0, 0,\";\n      ctx.fillStyle = color;\n      ctx.fillRect(0, 0, 1, 1);\n      const [r, g, b] = ctx.getImageData(0, 0, 1, 1).data;\n      return `rgba(${r}, ${g}, ${b},`;\n    };\n    return toRGBA(color);\n  }, [color]);\n\n  const setupCanvas = useCallback(\n    (canvas: HTMLCanvasElement) => {\n      const canvasWidth = width || canvas.clientWidth;\n      const canvasHeight = height || canvas.clientHeight;\n      const dpr = window.devicePixelRatio || 1;\n      canvas.width = canvasWidth * dpr;\n      canvas.height = canvasHeight * dpr;\n      canvas.style.width = `${canvasWidth}px`;\n      canvas.style.height = `${canvasHeight}px`;\n      const cols = Math.floor(canvasWidth / (squareSize + gridGap));\n      const rows = Math.floor(canvasHeight / (squareSize + gridGap));\n\n      const squares = new Float32Array(cols * rows);\n      for (let i = 0; i < squares.length; i++) {\n        squares[i] = Math.random() * maxOpacity;\n      }\n\n      return {\n        width: canvasWidth,\n        height: canvasHeight,\n        cols,\n        rows,\n        squares,\n        dpr,\n      };\n    },\n    [squareSize, gridGap, width, height, maxOpacity],\n  );\n\n  const updateSquares = useCallback(\n    (squares: Float32Array, deltaTime: number) => {\n      for (let i = 0; i < squares.length; i++) {\n        if (Math.random() < flickerChance * deltaTime) {\n          squares[i] = Math.random() * maxOpacity;\n        }\n      }\n    },\n    [flickerChance, maxOpacity],\n  );\n\n  const drawGrid = useCallback(\n    (\n      ctx: CanvasRenderingContext2D,\n      width: number,\n      height: number,\n      cols: number,\n      rows: number,\n      squares: Float32Array,\n      dpr: number,\n    ) => {\n      ctx.clearRect(0, 0, width, height);\n      ctx.fillStyle = \"transparent\";\n      ctx.fillRect(0, 0, width, height);\n\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < rows; j++) {\n          const opacity = squares[i * rows + j];\n          ctx.fillStyle = `${memoizedColor}${opacity})`;\n          ctx.fillRect(\n            i * (squareSize + gridGap) * dpr,\n            j * (squareSize + gridGap) * dpr,\n            squareSize * dpr,\n            squareSize * dpr,\n          );\n        }\n      }\n    },\n    [memoizedColor, squareSize, gridGap],\n  );\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const ctx = canvas.getContext(\"2d\");\n    if (!ctx) return;\n\n    let animationFrameId: number;\n    let { width, height, cols, rows, squares, dpr } = setupCanvas(canvas);\n\n    let lastTime = 0;\n    const animate = (time: number) => {\n      if (!isInView) return;\n\n      const deltaTime = (time - lastTime) / 1000;\n      lastTime = time;\n\n      updateSquares(squares, deltaTime);\n      drawGrid(ctx, width * dpr, height * dpr, cols, rows, squares, dpr);\n      animationFrameId = requestAnimationFrame(animate);\n    };\n\n    const handleResize = () => {\n      ({ width, height, cols, rows, squares, dpr } = setupCanvas(canvas));\n    };\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        setIsInView(entry.isIntersecting);\n      },\n      { threshold: 0 },\n    );\n\n    observer.observe(canvas);\n\n    window.addEventListener(\"resize\", handleResize);\n\n    if (isInView) {\n      animationFrameId = requestAnimationFrame(animate);\n    }\n\n    return () => {\n      window.removeEventListener(\"resize\", handleResize);\n      cancelAnimationFrame(animationFrameId);\n      observer.disconnect();\n    };\n  }, [setupCanvas, updateSquares, drawGrid, width, height, isInView]);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      className={`size-full pointer-events-none ${className}`}\n      style={{\n        width: width || \"100%\",\n        height: height || \"100%\",\n      }}\n      width={width}\n      height={height}\n    />\n  );\n};\n\nexport default FlickeringGrid;\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}